#include <WiFi.h>
#include <PubSubClient.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ArduinoJson.h>
#include "esp_heap_caps.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define RST_PIN 4
#define SS_PIN 5
#define ENCODER_PIN 32

LiquidCrystal_I2C lcd(0x27, 20, 4);

const byte ROWS = 4;
const byte COLS = 3;
char keys[ROWS][COLS] = {
  {'1','2','3'},
  {'4','5','6'},
  {'7','8','9'},
  {'*','0','#'}
};
byte rowPins[ROWS] = {12, 33, 16, 27};
byte colPins[COLS] = {14, 13, 17};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

const char* maquina_id = "MAQ01";
const char* ssid = "SSID-REDE";
const char* password = "SENHA-REDE";
const char* mqtt_server = "IP-BROKER";
const int mqtt_port = PORTA;
const char* mqtt_topic = "esp32";

WiFiClient espClient;
PubSubClient client(espClient);
MFRC522 rfid(SS_PIN, RST_PIN);

// Estrutura para paradas din√¢micas
struct Parada {
  int codigo;
  String nome;
  String nomeDisplay;
  bool* flag;
};

// Array de paradas - f√°cil de adicionar/remover
Parada paradas[] = {
  {1, "Banheiro", "Banheiro", NULL},
  {2, "Manutencao", "Manutencao", NULL},
  {3, "FaltaMaterial", "Falt. Material", NULL},
  {4, "QuebraAgulha", "Quebra Agulha", NULL},
  {5, "TrocaPeca", "Troca Peca", NULL}
  // Adicione mais paradas aqui seguindo o mesmo padr√£o
};

const int NUM_PARADAS = sizeof(paradas) / sizeof(paradas[0]);

String operador_id = "";
String referencia = "";
String referencia_uid = "";
bool tempoTrabalho = false, tempoProducao = false;
bool tempoBanheiro = false, tempoManutencao = false, tempoFaltaMaterial = false, tempoQuebraAgulha = false, tempoTrocaPeca = false;

// Vari√°veis para controle do modo parada
bool modoParadaAtivo = false;
String paradaAtual = "";

// Inicializar flags das paradas
void inicializarParadas() {
  paradas[0].flag = &tempoBanheiro;
  paradas[1].flag = &tempoManutencao;
  paradas[2].flag = &tempoFaltaMaterial;
  paradas[3].flag = &tempoQuebraAgulha;
  paradas[4].flag = &tempoTrocaPeca;
}

volatile unsigned long pulseCount = 0;
volatile unsigned long lastPulseTime = 0;
unsigned long lastRPMCheck = 0;
float rpm = 0;
float rpmBuffer[3] = {0, 0, 0};
int rpmIndex = 0;
float cpuLoad = 0.0f;

void IRAM_ATTR countPulse() {
  if (digitalRead(ENCODER_PIN) == LOW) {
    pulseCount++;
  }
}

void resetarParadas() {
  tempoBanheiro = tempoManutencao = tempoFaltaMaterial = tempoQuebraAgulha = tempoTrocaPeca = false;
  paradaAtual = "";
}

String lerUIDRFID() {
  String uid = "";
  if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
    for (byte i = 0; i < rfid.uid.size; i++) {
      if (rfid.uid.uidByte[i] < 0x10) uid += "0";
      uid += String(rfid.uid.uidByte[i], HEX);
    }
    uid.toUpperCase();
    
    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();
  }
  return uid;
}

void verificarRFID() {
  String uid = lerUIDRFID();
  if (uid == "") return;

  // Se n√£o h√° operador logado, este √© o login
  if (operador_id == "") {
    operador_id = uid;
    tempoTrabalho = true;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Login: " + operador_id.substring(0, 12));
    lcd.setCursor(0, 1);
    lcd.print("Insira Referencia...");
    Serial.println("‚úÖ Operador logado: " + operador_id);
  }
  // Se h√° operador logado mas n√£o h√° refer√™ncia, este √© o ref_op
  else if (referencia == "" && uid != operador_id) {
    referencia = uid;
    referencia_uid = uid;
    tempoProducao = true;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Login: " + operador_id.substring(0, 12));
    lcd.setCursor(0, 1);
    lcd.print("REF: " + referencia.substring(0, 12));
    Serial.println("‚úÖ Refer√™ncia definida: " + referencia);
  }
  // Logout do operador (mesmo UUID do login)
  else if (uid == operador_id) {
    operador_id = "";
    referencia = "";
    referencia_uid = "";
    tempoTrabalho = tempoProducao = false;
    resetarParadas();
    modoParadaAtivo = false;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Sistema Iniciado   ");
    lcd.setCursor(0, 1);
    lcd.print("Efetue o Login!    ");
    lcd.setCursor(0, 2);
    lcd.print("                    ");
    Serial.println("‚úÖ Logout do operador realizado");
  }
  // Logout da refer√™ncia (mesmo UUID da refer√™ncia)
  else if (uid == referencia_uid) {
    referencia = "";
    referencia_uid = "";
    tempoProducao = false;
    lcd.setCursor(0, 1);
    lcd.print("REF finalizada     ");
    delay(2000);
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Login: " + operador_id.substring(0, 12));
    lcd.setCursor(0, 1);
    lcd.print("Insira Referencia...");
    Serial.println("‚úÖ Refer√™ncia finalizada");
  }
  // Tentativa de usar outro RFID quando j√° h√° refer√™ncia ativa
  else {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("REF ja ativa!      ");
    lcd.setCursor(0, 1);
    lcd.print("Use mesmo REF p/sair");
    delay(2000);
    // Restaura display anterior
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Login: " + operador_id.substring(0, 12));
    lcd.setCursor(0, 1);
    lcd.print("REF: " + referencia.substring(0, 12));
    if (paradaAtual != "") {
      lcd.setCursor(0, 2);
      lcd.print("Parada: " + paradaAtual);
    }
    Serial.println("‚ö†Ô∏è Tentativa de usar outro RFID com refer√™ncia ativa");
  }
  
  delay(1000); // Debounce
}

void verificarTeclado() {
  if (operador_id == "") return;

  static String buffer = "";

  char key = keypad.getKey();
  if (!key) return;

  // Tecla * - Entrar/Sair do modo parada OU desativar parada atual
  if (key == '*') {
    if (!modoParadaAtivo && paradaAtual == "") {
      // Entrar no modo parada (s√≥ se n√£o h√° parada ativa)
      modoParadaAtivo = true;
      buffer = "";
      lcd.setCursor(0, 2);
      lcd.print("Insira parada...   ");
      lcd.setCursor(0, 3);
      lcd.print("                    "); // Limpa RPM temporariamente
      Serial.println("üìù Modo parada ativado");
    } 
    else if (!modoParadaAtivo && paradaAtual != "") {
      // Desativar parada atual (quando j√° h√° uma parada ativa)
      desativarTodasParadas();
      paradaAtual = "";
      tempoProducao = true;
      lcd.setCursor(0, 2);
      lcd.print("                    ");
      Serial.println("‚ñ∂Ô∏è Parada desativada via *");
    }
    else if (modoParadaAtivo) {
      // Sair do modo parada sem fazer nada
      modoParadaAtivo = false;
      buffer = "";
      lcd.setCursor(0, 2);
      lcd.print("                    ");
      if (paradaAtual != "") {
        lcd.setCursor(0, 2);
        lcd.print("Parada: " + paradaAtual);
      }
      Serial.println("‚ùå Modo parada cancelado");
    }
    return;
  }

  // Se modo parada est√° ativo, processar teclas num√©ricas
  if (modoParadaAtivo && key >= '0' && key <= '9') {
    buffer += key;
    lcd.setCursor(0, 2);
    lcd.print("Insira parada: " + buffer);
  }

  // Tecla # - Confirmar parada
  if (key == '#' && modoParadaAtivo && buffer.length() > 0) {
    int codigo = buffer.toInt();
    bool paradaEncontrada = false;
    
    // Buscar parada pelo c√≥digo
    for (int i = 0; i < NUM_PARADAS; i++) {
      if (paradas[i].codigo == codigo) {
        paradaEncontrada = true;
        bool* paradaFlag = paradas[i].flag;
        
        // Se j√° tem parada ativa, desativa todas primeiro
        if (paradaAtual != "") {
          desativarTodasParadas();
        }
        
        // Ativar nova parada
        *paradaFlag = true;
        tempoProducao = false;
        paradaAtual = paradas[i].nomeDisplay;
        lcd.setCursor(0, 2);
        lcd.print("Parada: " + paradaAtual);
        Serial.println("‚è∏Ô∏è Parada ativada: " + paradas[i].nomeDisplay);
        
        break;
      }
    }
    
    if (!paradaEncontrada) {
      lcd.setCursor(0, 2);
      lcd.print("Codigo invalido!   ");
      delay(2000);
      if (paradaAtual != "") {
        lcd.setCursor(0, 2);
        lcd.print("Parada: " + paradaAtual);
      } else {
        lcd.setCursor(0, 2);
        lcd.print("                    ");
      }
    }
    
    modoParadaAtivo = false;
    buffer = "";
  }
}

// Fun√ß√£o para desativar todas as paradas
void desativarTodasParadas() {
  for (int i = 0; i < NUM_PARADAS; i++) {
    *paradas[i].flag = false;
  }
}

float getCPULoad() {
  static unsigned long lastIdle = 0, lastTotal = 0;
  unsigned long idle = ulTaskGetIdleRunTimeCounter();
  unsigned long total = portGET_RUN_TIME_COUNTER_VALUE();
  unsigned long idleDelta = idle - lastIdle;
  unsigned long totalDelta = total - lastTotal;
  lastIdle = idle;
  lastTotal = total;
  if (totalDelta == 0) return 0.0;
  return (1.0 - ((float)idleDelta / totalDelta)) * 100.0;
}

void enviarJSON() {
  StaticJsonDocument<512> doc;
  size_t totalHeap = heap_caps_get_total_size(MALLOC_CAP_DEFAULT);
  if (totalHeap == 0) totalHeap = 1;
  float heapPorcentagemUsada = ((totalHeap - esp_get_free_heap_size()) * 100.0) / totalHeap;

  doc["maquina_id"] = maquina_id;
  doc["operador"] = operador_id;
  doc["ref_op"] = referencia;
  doc["tempoTrabalho"] = tempoTrabalho;
  doc["tempoProducao"] = tempoProducao;
  
  // Adicionar paradas dinamicamente ao JSON
  for (int i = 0; i < NUM_PARADAS; i++) {
    doc[paradas[i].nome] = *paradas[i].flag;
  }
  
  JsonArray rpmArray = doc.createNestedArray("rpm");
  rpmArray.add(rpmBuffer[0]);
  rpmArray.add(rpmBuffer[1]);
  rpmArray.add(rpmBuffer[2]);
  
  doc["cpuLoad"] = roundf(cpuLoad * 100) / 100.0;
  doc["heapLoad"] = roundf(heapPorcentagemUsada * 100) / 100.0;

  char jsonBuffer[512];
  size_t len = serializeJson(doc, jsonBuffer);

  Serial.println("JSON Gerado:");
  Serial.println(jsonBuffer);

  if (client.connected()) {
    if (client.publish(mqtt_topic, jsonBuffer)) Serial.println("‚úÖ JSON enviado com sucesso.");
    else Serial.println("‚ùå Falha ao enviar JSON.");
  } else {
    Serial.println("‚ö†Ô∏è MQTT desconectado.");
  }
}

void atualizarDisplay() {
  // Linha 0: Sistema Iniciado / Login
  lcd.setCursor(0, 0);
  if (operador_id == "") {
    lcd.print("Sistema Iniciado   ");
  } else {
    String loginText = "Login: " + operador_id.substring(0, 12);
    lcd.print(loginText);
    for (int i = loginText.length(); i < 20; i++) {
      lcd.print(' ');
    }
  }

  // Linha 1: Efetue Login / Refer√™ncia
  lcd.setCursor(0, 1);
  if (operador_id == "") {
    lcd.print("Efetue o Login!    ");
  } else if (referencia == "") {
    lcd.print("Insira Referencia...");
  } else {
    String refText = "REF: " + referencia.substring(0, 12);
    lcd.print(refText);
    for (int i = refText.length(); i < 20; i++) {
      lcd.print(' ');
    }
  }

  // Linha 2: Parada (s√≥ aparece quando ativa ou no modo inser√ß√£o)
  // Esta linha √© gerenciada diretamente nas fun√ß√µes de teclado e RFID

  // Linha 3: RPM (sempre sozinho)
  lcd.setCursor(0, 3);
  lcd.print("                    "); // Limpar linha
  lcd.setCursor(0, 3);
  lcd.printf("RPM: %.0f", rpm);
}

void conectarWiFi() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Conectando WiFi...");
  
  WiFi.begin(ssid, password);
  int tentativas = 0;
  while (WiFi.status() != WL_CONNECTED && tentativas < 10) {
    delay(500);
    Serial.print(".");
    tentativas++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ WiFi conectado!");
    Serial.println(WiFi.localIP());

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("WiFi conectado     ");
    lcd.setCursor(0, 1);
    lcd.print(WiFi.localIP());
    delay(2000);
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Sistema Iniciado   ");
    lcd.setCursor(0, 1);
    lcd.print("Efetue o Login!    ");
  } else {
    Serial.println("\n‚ùå Falha ao conectar WiFi.");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Falha WiFi         ");
    lcd.setCursor(0, 1);
    lcd.print("Verifique rede     ");
  }
}

void conectarMQTT() {
  client.setServer(mqtt_server, mqtt_port);
  int tentativas = 0;
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Conectando MQTT... ");

  while (!client.connected() && tentativas < 5) {
    Serial.print("Tentando MQTT... ");
    if (client.connect(maquina_id)) {
      Serial.println("‚úÖ Conectado ao MQTT!");
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("MQTT conectado     ");
      delay(2000);
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Sistema Iniciado   ");
      lcd.setCursor(0, 1);
      lcd.print("Efetue o Login!    ");
      return;
    } else {
      Serial.print("‚ùå Falha (rc=");
      Serial.print(client.state());
      Serial.println("), nova tentativa...");
      delay(1000);
      tentativas++;
    }
  }

  Serial.println("‚ùå Erro: n√£o conectou ao MQTT!");
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Falha MQTT         ");
  lcd.setCursor(0, 1);
  lcd.print("Verifique broker   ");
}

void setup() {
  Serial.begin(115200);
  pinMode(ENCODER_PIN, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENCODER_PIN), countPulse, FALLING);

  Wire.begin(21, 22);
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Sistema Iniciado");
  lcd.setCursor(0, 1);
  lcd.print("Efetue o Login!");

  SPI.begin();
  rfid.PCD_Init();
  
  // Inicializar paradas
  inicializarParadas();

  conectarWiFi();
  conectarMQTT();
}

void loop() {
  static bool wifiTentado = false;
  if (WiFi.status() != WL_CONNECTED && !wifiTentado) {
    conectarWiFi();
    wifiTentado = true;
  }

  static bool mqttTentado = false;
  if (!client.connected() && WiFi.status() == WL_CONNECTED && !mqttTentado) {
    conectarMQTT();
    mqttTentado = false;
  }

  client.loop();
  verificarRFID();
  verificarTeclado();
  atualizarDisplay();

  // C√°lculo do RPM
  if (millis() - lastRPMCheck >= 1000) {
    detachInterrupt(digitalPinToInterrupt(ENCODER_PIN));
    rpm = (pulseCount * 60.0);
    pulseCount = 0;
    lastRPMCheck = millis();
    attachInterrupt(digitalPinToInterrupt(ENCODER_PIN), countPulse, FALLING);

    rpmBuffer[rpmIndex] = rpm;
    rpmIndex = (rpmIndex + 1) % 3;

    cpuLoad = getCPULoad();
  }

  // Envio JSON a cada 3s
  static unsigned long ultimaMensagem = 0;
  if (millis() - ultimaMensagem >= 3000) {
    enviarJSON();
    ultimaMensagem = millis();
  }

  vTaskDelay(pdMS_TO_TICKS(20));
}

/* 
  Sistema desenvolvido por: Kalebe e Jo√£o Victor
*/
