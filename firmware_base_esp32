/**
 * =============================================================================
 * SISTEMA DE MONITORAMENTO DE PRODUÇÃO - ESP32
 * Versão: 2.0.0 (Refactored)
 * =============================================================================
 *
 * Arquitetura:
 * - Máquina de estados formal com transições validadas
 * - Zero blocking delays no loop principal
 * - Buffer circular para RPM com ordem cronológica correta
 * - Reconexão WiFi/MQTT com backoff exponencial
 * - Strings fixas (char[]) em vez de String dinâmico
 * - Display com dirty flag (atualiza só quando necessário)
 * - ISR otimizada sem leituras redundantes
 * - Envio condicional de payload (mudança de estado OU intervalo)
 *
 * Desenvolvedores: Kalebe Felix, João Victor
 * Refatoração: João Ícaro
 * =============================================================================
 */

#include <WiFi.h>
#include <PubSubClient.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ArduinoJson.h>
#include "esp_heap_caps.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// =============================================================================
// CONFIGURAÇÃO DE HARDWARE
// =============================================================================
#define RST_PIN         4
#define SS_PIN          5
#define ENCODER_PIN     32
#define I2C_SDA         21
#define I2C_SCL         22
#define LCD_ADDR        0x27
#define LCD_COLS        20
#define LCD_ROWS        4

// =============================================================================
// CONFIGURAÇÃO DE REDE (TODO: Mover para NVS/SPIFFS em produção)
// =============================================================================
namespace Config {
    const char* MACHINE_ID   = "MAQ01";
    const char* WIFI_SSID    = "SSID-REDE";
    const char* WIFI_PASS    = "SENHA-REDE";
    const char* MQTT_SERVER  = "192.168.1.100";
    const uint16_t MQTT_PORT = 1883;
    const char* MQTT_TOPIC   = "producao/maquinas";
}

// =============================================================================
// CONSTANTES DE TIMING (em milissegundos)
// =============================================================================
namespace Timing {
    const uint32_t RPM_CALC_INTERVAL    = 1000;   // Calcular RPM a cada 1s
    const uint32_t MQTT_SEND_INTERVAL   = 3000;   // Enviar MQTT a cada 3s
    const uint32_t DISPLAY_REFRESH      = 250;    // Atualizar display 4x/s
    const uint32_t RFID_DEBOUNCE        = 1500;   // Debounce RFID
    const uint32_t WIFI_RETRY_BASE      = 5000;   // Base retry WiFi
    const uint32_t WIFI_RETRY_MAX       = 60000;  // Max retry WiFi
    const uint32_t MQTT_RETRY_BASE      = 2000;   // Base retry MQTT
    const uint32_t MQTT_RETRY_MAX       = 30000;  // Max retry MQTT
    const uint32_t LCD_MESSAGE_DURATION = 2000;   // Mensagens temporárias
}

// =============================================================================
// MÁQUINA DE ESTADOS
// =============================================================================
typedef enum : uint8_t {
    STATE_IDLE = 0,        // Aguardando login do operador
    STATE_LOGGED_IN,       // Operador logado, aguardando referência
    STATE_PRODUCING,       // Produzindo (com referência)
    STATE_PAUSED           // Parada ativa
} SystemState;

const char* STATE_NAMES[] = {
    "IDLE", "LOGGED_IN", "PRODUCING", "PAUSED"
};

// =============================================================================
// TIPOS DE PARADA
// =============================================================================
typedef enum : uint8_t {
    PARADA_NONE = 0,
    PARADA_BANHEIRO = 1,
    PARADA_MANUTENCAO = 2,
    PARADA_FALTA_MATERIAL = 3,
    PARADA_QUEBRA_AGULHA = 4,
    PARADA_TROCA_PECA = 5,
    PARADA_COUNT = 6
} ParadaTipo;

typedef struct {
    const char* json_name;
    const char* display_name;
} ParadaInfo;

const ParadaInfo PARADAS[PARADA_COUNT] = {
    {"none",          ""},
    {"Banheiro",      "Banheiro"},
    {"Manutencao",    "Manutencao"},
    {"FaltaMaterial", "Falt. Material"},
    {"QuebraAgulha",  "Quebra Agulha"},
    {"TrocaPeca",     "Troca Peca"}
};

// =============================================================================
// CONTEXTO DO SISTEMA (substitui variáveis globais dispersas)
// =============================================================================
typedef struct {
    // Estado principal
    SystemState state;
    SystemState prev_state;

    // Identificadores (8 hex chars + null)
    char operador_uid[9];
    char referencia_uid[9];

    // Parada
    ParadaTipo parada_ativa;

    // RPM - Buffer circular com índice de escrita
    volatile uint32_t pulse_count;
    uint32_t rpm_buffer[3];
    uint8_t rpm_write_index;
    float rpm_atual;

    // Timestamps (não-bloqueante)
    uint32_t last_rpm_calc;
    uint32_t last_mqtt_send;
    uint32_t last_display_update;
    uint32_t last_rfid_read;
    uint32_t last_wifi_attempt;
    uint32_t last_mqtt_attempt;
    uint32_t temp_message_start;

    // Backoff exponencial
    uint32_t wifi_retry_delay;
    uint32_t mqtt_retry_delay;

    // Flags de controle
    bool display_dirty;
    bool state_changed;
    bool mqtt_send_pending;
    bool temp_message_active;
    bool modo_parada_input;

    // Buffer de entrada teclado
    char keypad_buffer[4];
    uint8_t keypad_buffer_len;

    // Métricas do sistema
    float cpu_load;
    float heap_load;

    // Mensagem temporária
    char temp_message[21];
} SystemContext;

// Instância global do contexto
static SystemContext ctx;

// =============================================================================
// OBJETOS DE HARDWARE
// =============================================================================
LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);
MFRC522 rfid(SS_PIN, RST_PIN);
WiFiClient wifiClient;
PubSubClient mqtt(wifiClient);

// Configuração do teclado
const byte KEYPAD_ROWS = 4;
const byte KEYPAD_COLS = 3;
char keypad_keys[KEYPAD_ROWS][KEYPAD_COLS] = {
    {'1', '2', '3'},
    {'4', '5', '6'},
    {'7', '8', '9'},
    {'*', '0', '#'}
};
byte keypad_row_pins[KEYPAD_ROWS] = {12, 33, 16, 27};
byte keypad_col_pins[KEYPAD_COLS] = {14, 13, 17};
Keypad keypad = Keypad(makeKeymap(keypad_keys), keypad_row_pins, keypad_col_pins, KEYPAD_ROWS, KEYPAD_COLS);

// =============================================================================
// ISR - CONTAGEM DE PULSOS (Otimizada)
// =============================================================================
void IRAM_ATTR onEncoderPulse() {
    if (digitalRead(ENCODER_PIN) == LOW) {
        ctx.pulse_count++;
    }
}

// =============================================================================
// INICIALIZAÇÃO DO CONTEXTO
// =============================================================================
void initContext() {
    memset(&ctx, 0, sizeof(SystemContext));
    ctx.state = STATE_IDLE;
    ctx.prev_state = STATE_IDLE;
    ctx.parada_ativa = PARADA_NONE;
    ctx.display_dirty = true;
    ctx.wifi_retry_delay = Timing::WIFI_RETRY_BASE;
    ctx.mqtt_retry_delay = Timing::MQTT_RETRY_BASE;
}

// =============================================================================
// TRANSIÇÃO DE ESTADOS (com validação)
// =============================================================================
bool transitionTo(SystemState new_state) {
    // Validar transições permitidas
    bool valid = false;

    switch (ctx.state) {
        case STATE_IDLE:
            valid = (new_state == STATE_LOGGED_IN);
            break;
        case STATE_LOGGED_IN:
            valid = (new_state == STATE_IDLE || new_state == STATE_PRODUCING);
            break;
        case STATE_PRODUCING:
            valid = (new_state == STATE_LOGGED_IN || new_state == STATE_PAUSED || new_state == STATE_IDLE);
            break;
        case STATE_PAUSED:
            valid = (new_state == STATE_PRODUCING || new_state == STATE_LOGGED_IN || new_state == STATE_IDLE);
            break;
    }

    if (!valid) {
        Serial.printf("[FSM] Transicao invalida: %s -> %s\n",
            STATE_NAMES[ctx.state], STATE_NAMES[new_state]);
        return false;
    }

    Serial.printf("[FSM] %s -> %s\n", STATE_NAMES[ctx.state], STATE_NAMES[new_state]);
    ctx.prev_state = ctx.state;
    ctx.state = new_state;
    ctx.state_changed = true;
    ctx.display_dirty = true;
    ctx.mqtt_send_pending = true;

    return true;
}

// =============================================================================
// DISPLAY - Mensagem Temporária (não bloqueante)
// =============================================================================
void showTempMessage(const char* msg) {
    strncpy(ctx.temp_message, msg, 20);
    ctx.temp_message[20] = '\0';
    ctx.temp_message_active = true;
    ctx.temp_message_start = millis();
    ctx.display_dirty = true;
}

// =============================================================================
// DISPLAY - Atualização Principal
// =============================================================================
void updateDisplay() {
    uint32_t now = millis();

    // Verificar se mensagem temporária expirou
    if (ctx.temp_message_active &&
        (now - ctx.temp_message_start >= Timing::LCD_MESSAGE_DURATION)) {
        ctx.temp_message_active = false;
        ctx.display_dirty = true;
    }

    // Só atualizar se dirty OU intervalo de refresh
    if (!ctx.display_dirty &&
        (now - ctx.last_display_update < Timing::DISPLAY_REFRESH)) {
        return;
    }

    ctx.last_display_update = now;
    ctx.display_dirty = false;

    // Linha 0: Status do operador
    lcd.setCursor(0, 0);
    if (ctx.operador_uid[0] == '\0') {
        lcd.print("Sistema Iniciado    ");
    } else {
        lcd.printf("Login: %-12s", ctx.operador_uid);
    }

    // Linha 1: Referência ou instrução
    lcd.setCursor(0, 1);
    if (ctx.temp_message_active) {
        lcd.printf("%-20s", ctx.temp_message);
    } else if (ctx.operador_uid[0] == '\0') {
        lcd.print("Efetue o Login!     ");
    } else if (ctx.referencia_uid[0] == '\0') {
        lcd.print("Insira Referencia...");
    } else {
        lcd.printf("REF: %-14s", ctx.referencia_uid);
    }

    // Linha 2: Parada ou input mode
    lcd.setCursor(0, 2);
    if (ctx.modo_parada_input) {
        lcd.printf("Parada: %-12s", ctx.keypad_buffer);
    } else if (ctx.parada_ativa != PARADA_NONE) {
        lcd.printf("Parada: %-12s", PARADAS[ctx.parada_ativa].display_name);
    } else {
        lcd.print("                    ");
    }

    // Linha 3: RPM
    lcd.setCursor(0, 3);
    lcd.print("RPM: ");
    lcd.print((int)ctx.rpm_atual);
    lcd.print("               ");  // Limpar resto da linha
}

// =============================================================================
// RFID - Leitura e Processamento
// =============================================================================
bool readRfidUid(char* uid_out) {
    if (!rfid.PICC_IsNewCardPresent() || !rfid.PICC_ReadCardSerial()) {
        return false;
    }

    // Converter para hex string
    for (byte i = 0; i < rfid.uid.size && i < 4; i++) {
        sprintf(&uid_out[i * 2], "%02X", rfid.uid.uidByte[i]);
    }
    uid_out[8] = '\0';

    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();

    return true;
}

void processRfid() {
    uint32_t now = millis();

    // Debounce não-bloqueante
    if (now - ctx.last_rfid_read < Timing::RFID_DEBOUNCE) {
        return;
    }

    char uid[9];
    if (!readRfidUid(uid)) {
        return;
    }

    ctx.last_rfid_read = now;
    Serial.printf("[RFID] UID lido: %s\n", uid);

    switch (ctx.state) {
        case STATE_IDLE:
            // Login do operador
            strncpy(ctx.operador_uid, uid, 9);
            transitionTo(STATE_LOGGED_IN);
            Serial.printf("[RFID] Operador logado: %s\n", ctx.operador_uid);
            break;

        case STATE_LOGGED_IN:
            if (strcmp(uid, ctx.operador_uid) == 0) {
                // Logout do operador
                ctx.operador_uid[0] = '\0';
                transitionTo(STATE_IDLE);
                Serial.println("[RFID] Logout do operador");
            } else {
                // Definir referência
                strncpy(ctx.referencia_uid, uid, 9);
                transitionTo(STATE_PRODUCING);
                Serial.printf("[RFID] Referencia definida: %s\n", ctx.referencia_uid);
            }
            break;

        case STATE_PRODUCING:
        case STATE_PAUSED:
            if (strcmp(uid, ctx.operador_uid) == 0) {
                // Logout completo
                ctx.operador_uid[0] = '\0';
                ctx.referencia_uid[0] = '\0';
                ctx.parada_ativa = PARADA_NONE;
                ctx.modo_parada_input = false;
                transitionTo(STATE_IDLE);
                Serial.println("[RFID] Logout completo");
            } else if (strcmp(uid, ctx.referencia_uid) == 0) {
                // Finalizar referência
                ctx.referencia_uid[0] = '\0';
                ctx.parada_ativa = PARADA_NONE;
                transitionTo(STATE_LOGGED_IN);
                showTempMessage("REF finalizada");
                Serial.println("[RFID] Referencia finalizada");
            } else {
                // Outro cartão - não permitido
                showTempMessage("REF ja ativa!");
                Serial.println("[RFID] Tentativa rejeitada");
            }
            break;
    }
}

// =============================================================================
// TECLADO - Processamento
// =============================================================================
void processKeypad() {
    // Só processa se logado
    if (ctx.state == STATE_IDLE) {
        return;
    }

    char key = keypad.getKey();
    if (key == 0) {
        return;
    }

    Serial.printf("[KEY] Tecla: %c\n", key);

    switch (key) {
        case '*':
            if (ctx.modo_parada_input) {
                // Cancelar entrada
                ctx.modo_parada_input = false;
                ctx.keypad_buffer_len = 0;
                ctx.keypad_buffer[0] = '\0';
                ctx.display_dirty = true;
            } else if (ctx.parada_ativa != PARADA_NONE) {
                // Desativar parada atual
                ctx.parada_ativa = PARADA_NONE;
                if (ctx.state == STATE_PAUSED) {
                    transitionTo(STATE_PRODUCING);
                }
                Serial.println("[KEY] Parada desativada");
            } else if (ctx.state == STATE_PRODUCING) {
                // Entrar modo parada
                ctx.modo_parada_input = true;
                ctx.keypad_buffer_len = 0;
                ctx.keypad_buffer[0] = '\0';
                ctx.display_dirty = true;
                Serial.println("[KEY] Modo parada ativado");
            }
            break;

        case '#':
            if (ctx.modo_parada_input && ctx.keypad_buffer_len > 0) {
                // Confirmar parada
                int codigo = atoi(ctx.keypad_buffer);
                if (codigo >= 1 && codigo < PARADA_COUNT) {
                    ctx.parada_ativa = (ParadaTipo)codigo;
                    transitionTo(STATE_PAUSED);
                    Serial.printf("[KEY] Parada ativada: %s\n",
                        PARADAS[ctx.parada_ativa].display_name);
                } else {
                    showTempMessage("Codigo invalido!");
                }
                ctx.modo_parada_input = false;
                ctx.keypad_buffer_len = 0;
                ctx.keypad_buffer[0] = '\0';
            }
            break;

        default:
            if (ctx.modo_parada_input && key >= '0' && key <= '9') {
                if (ctx.keypad_buffer_len < 2) {  // Máximo 2 dígitos
                    ctx.keypad_buffer[ctx.keypad_buffer_len++] = key;
                    ctx.keypad_buffer[ctx.keypad_buffer_len] = '\0';
                    ctx.display_dirty = true;
                }
            }
            break;
    }
}

// =============================================================================
// RPM - Cálculo
// =============================================================================
void calculateRpm() {
    uint32_t now = millis();

    if (now - ctx.last_rpm_calc < Timing::RPM_CALC_INTERVAL) {
        return;
    }

    // Ler e resetar contador atomicamente
    portDISABLE_INTERRUPTS();
    uint32_t pulses = ctx.pulse_count;
    ctx.pulse_count = 0;
    portENABLE_INTERRUPTS();

    // Calcular RPM (pulsos por minuto)
    ctx.rpm_atual = pulses * 60.0f;

    // Armazenar no buffer circular
    ctx.rpm_buffer[ctx.rpm_write_index] = (uint32_t)ctx.rpm_atual;
    ctx.rpm_write_index = (ctx.rpm_write_index + 1) % 3;

    ctx.last_rpm_calc = now;
    ctx.display_dirty = true;
}

// =============================================================================
// MÉTRICAS DO SISTEMA
// =============================================================================
void updateMetrics() {
    // Heap usage
    size_t total_heap = heap_caps_get_total_size(MALLOC_CAP_DEFAULT);
    size_t free_heap = esp_get_free_heap_size();
    ctx.heap_load = (total_heap > 0) ?
        ((total_heap - free_heap) * 100.0f / total_heap) : 0.0f;

    // CPU load (simplificado - requer config FreeRTOS específica)
    // Em produção, usar ulTaskGetIdleRunTimeCounter() se disponível
    ctx.cpu_load = 0.0f;  // Placeholder
}

// =============================================================================
// MQTT - Envio de JSON
// =============================================================================
void sendMqttPayload() {
    uint32_t now = millis();

    // Enviar se: intervalo atingido OU mudança de estado
    bool should_send = (now - ctx.last_mqtt_send >= Timing::MQTT_SEND_INTERVAL) ||
                       ctx.mqtt_send_pending;

    if (!should_send || !mqtt.connected()) {
        return;
    }

    ctx.last_mqtt_send = now;
    ctx.mqtt_send_pending = false;

    updateMetrics();

    // Construir JSON (formato otimizado - state como single source of truth)
    StaticJsonDocument<256> doc;

    doc["maquina_id"] = Config::MACHINE_ID;
    doc["operador"] = ctx.operador_uid;
    doc["ref_op"] = ctx.referencia_uid;
    doc["state"] = STATE_NAMES[ctx.state];
    doc["parada"] = PARADAS[ctx.parada_ativa].json_name;

    // RPM em ordem cronológica (mais antigo primeiro)
    JsonArray rpm_array = doc.createNestedArray("rpm");
    for (int i = 0; i < 3; i++) {
        uint8_t idx = (ctx.rpm_write_index + i) % 3;
        rpm_array.add(ctx.rpm_buffer[idx]);
    }

    doc["cpuLoad"] = roundf(ctx.cpu_load * 100) / 100.0f;
    doc["heapLoad"] = roundf(ctx.heap_load * 100) / 100.0f;

    // Serializar e enviar
    char buffer[256];
    size_t len = serializeJson(doc, buffer);

    if (mqtt.publish(Config::MQTT_TOPIC, buffer, len)) {
        Serial.printf("[MQTT] Enviado (%d bytes)\n", len);
    } else {
        Serial.println("[MQTT] Erro ao enviar");
    }
}

// =============================================================================
// WIFI - Conexão com backoff exponencial
// =============================================================================
void handleWifiConnection() {
    if (WiFi.status() == WL_CONNECTED) {
        ctx.wifi_retry_delay = Timing::WIFI_RETRY_BASE;  // Reset backoff
        return;
    }

    uint32_t now = millis();
    if (now - ctx.last_wifi_attempt < ctx.wifi_retry_delay) {
        return;
    }

    ctx.last_wifi_attempt = now;
    Serial.printf("[WIFI] Conectando... (retry em %lums)\n", ctx.wifi_retry_delay);

    lcd.setCursor(0, 1);
    lcd.print("Conectando WiFi...  ");

    WiFi.disconnect();
    WiFi.begin(Config::WIFI_SSID, Config::WIFI_PASS);

    // Aguardar até 5 segundos (não-bloqueante seria melhor, mas WiFi.begin é síncrono)
    uint32_t start = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - start < 5000) {
        delay(100);
    }

    if (WiFi.status() == WL_CONNECTED) {
        Serial.printf("[WIFI] Conectado! IP: %s\n", WiFi.localIP().toString().c_str());
        ctx.wifi_retry_delay = Timing::WIFI_RETRY_BASE;
        ctx.display_dirty = true;
    } else {
        // Backoff exponencial
        ctx.wifi_retry_delay = min(ctx.wifi_retry_delay * 2, Timing::WIFI_RETRY_MAX);
        Serial.printf("[WIFI] Falha. Proximo retry em %lums\n", ctx.wifi_retry_delay);
    }
}

// =============================================================================
// MQTT - Conexão com backoff exponencial
// =============================================================================
void handleMqttConnection() {
    if (mqtt.connected()) {
        ctx.mqtt_retry_delay = Timing::MQTT_RETRY_BASE;
        return;
    }

    if (WiFi.status() != WL_CONNECTED) {
        return;
    }

    uint32_t now = millis();
    if (now - ctx.last_mqtt_attempt < ctx.mqtt_retry_delay) {
        return;
    }

    ctx.last_mqtt_attempt = now;
    Serial.printf("[MQTT] Conectando... (retry em %lums)\n", ctx.mqtt_retry_delay);

    if (mqtt.connect(Config::MACHINE_ID)) {
        Serial.println("[MQTT] Conectado!");
        ctx.mqtt_retry_delay = Timing::MQTT_RETRY_BASE;
        ctx.mqtt_send_pending = true;  // Enviar estado atual imediatamente
    } else {
        ctx.mqtt_retry_delay = min(ctx.mqtt_retry_delay * 2, Timing::MQTT_RETRY_MAX);
        Serial.printf("[MQTT] Falha (rc=%d). Proximo retry em %lums\n",
            mqtt.state(), ctx.mqtt_retry_delay);
    }
}

// =============================================================================
// SETUP
// =============================================================================
void setup() {
    Serial.begin(115200);
    Serial.println("\n[BOOT] Sistema de Monitoramento v2.0");

    // Inicializar contexto
    initContext();

    // Configurar pino do encoder
    pinMode(ENCODER_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(ENCODER_PIN), onEncoderPulse, FALLING);

    // Inicializar I2C e LCD
    Wire.begin(I2C_SDA, I2C_SCL);
    lcd.init();
    lcd.backlight();
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Iniciando...");

    // Inicializar SPI e RFID
    SPI.begin();
    rfid.PCD_Init();
    delay(100);

    if (rfid.PCD_PerformSelfTest()) {
        Serial.println("[RFID] Self-test OK");
    } else {
        Serial.println("[RFID] Self-test FALHOU");
    }
    rfid.PCD_Init();  // Re-init após self-test

    // Configurar MQTT
    mqtt.setServer(Config::MQTT_SERVER, Config::MQTT_PORT);
    mqtt.setBufferSize(512);

    // Conexão inicial
    handleWifiConnection();
    handleMqttConnection();

    ctx.display_dirty = true;
    Serial.println("[BOOT] Setup completo");
}

// =============================================================================
// LOOP PRINCIPAL (Zero blocking delays)
// =============================================================================
void loop() {
    // Gerenciar conexões
    handleWifiConnection();
    handleMqttConnection();
    mqtt.loop();

    // Processar entradas
    processRfid();
    processKeypad();

    // Calcular métricas
    calculateRpm();

    // Atualizar saídas
    updateDisplay();
    sendMqttPayload();

    // Reset flag de mudança de estado
    ctx.state_changed = false;

    // Yield para outras tasks do FreeRTOS
    vTaskDelay(pdMS_TO_TICKS(10));
}
