/**
 * =============================================================================
 * SISTEMA DE MONITORAMENTO DE PRODUÇÃO - ESP32
 * Versão: 2.1.0 (Production-Ready + NTP Sync)
 * =============================================================================
 *
 * Arquitetura:
 * - Máquina de estados formal com transições validadas
 * - Zero blocking delays no loop principal
 * - Buffer circular para RPM com ordem cronológica correta
 * - Reconexão WiFi/MQTT com backoff exponencial
 * - Strings fixas (char[]) em vez de String dinâmico
 * - Display com dirty flag (atualiza só quando necessário)
 * - ISR otimizada sem leituras redundantes
 * - Envio condicional de payload (mudança de estado OU intervalo)
 * - SINCRONIZAÇÃO NTP: Envio MQTT em múltiplos exatos de 3s (00:00:00, 00:00:03, 00:00:06...)
 *
 * Desenvolvedores: Kalebe Felix, João Victor
 * Refatoração: João Ícaro
 * =============================================================================
 */

#include <WiFi.h>
#include <PubSubClient.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ArduinoJson.h>
#include <time.h>
#include "esp_heap_caps.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_sntp.h"

// =============================================================================
// CONFIGURAÇÃO DE DEBUG
// =============================================================================
// Descomente para habilitar debug serial (adiciona ~5-10% CPU overhead)
#define DEBUG_SERIAL

#ifdef DEBUG_SERIAL
    #define DEBUG_PRINT(x) Serial.print(x)
    #define DEBUG_PRINTLN(x) Serial.println(x)
    #define DEBUG_PRINTF(...) Serial.printf(__VA_ARGS__)
#else
    #define DEBUG_PRINT(x)
    #define DEBUG_PRINTLN(x)
    #define DEBUG_PRINTF(...)
#endif

// =============================================================================
// CONFIGURAÇÃO DE HARDWARE
// =============================================================================
#define RST_PIN         4
#define SS_PIN          5
#define ENCODER_PIN     32
#define I2C_SDA         21
#define I2C_SCL         22
#define LCD_ADDR        0x27
#define LCD_COLS        20
#define LCD_ROWS        4

// =============================================================================
// CONFIGURAÇÃO DE REDE (TODO: Mover para NVS/SPIFFS em produção)
// =============================================================================
namespace Config {
    const char* MACHINE_ID   = "MAQ01";
    const char* WIFI_SSID    = "SSID-REDE";
    const char* WIFI_PASS    = "SENHA-REDE";
    const char* MQTT_SERVER  = "192.168.1.100";
    const uint16_t MQTT_PORT = 1883;
    const char* MQTT_TOPIC   = "producao/maquinas";

    // Configuração NTP
    const char* NTP_SERVER1  = "pool.ntp.org";
    const char* NTP_SERVER2  = "time.nist.gov";
    const long  GMT_OFFSET   = -3 * 3600;  // UTC-3 (Brasília)
    const int   DST_OFFSET   = 0;          // Sem horário de verão
}

// =============================================================================
// CONSTANTES DE TIMING (em milissegundos)
// =============================================================================
namespace Timing {
    const uint32_t RPM_CALC_INTERVAL    = 1000;   // Calcular RPM a cada 1s
    const uint32_t MQTT_SEND_INTERVAL   = 3000;   // Enviar MQTT a cada 3s (sincronizado)
    const uint32_t DISPLAY_REFRESH      = 250;    // Atualizar display 4x/s
    const uint32_t RFID_POLL_INTERVAL   = 100;    // Polling RFID 10x/s
    const uint32_t RFID_DEBOUNCE        = 1500;   // Debounce RFID
    const uint32_t WIFI_RETRY_BASE      = 5000;   // Base retry WiFi
    const uint32_t WIFI_RETRY_MAX       = 60000;  // Max retry WiFi
    const uint32_t MQTT_RETRY_BASE      = 2000;   // Base retry MQTT
    const uint32_t MQTT_RETRY_MAX       = 30000;  // Max retry MQTT
    const uint32_t LCD_MESSAGE_DURATION = 2000;   // Mensagens temporárias
    const uint32_t NTP_SYNC_CHECK       = 3600000; // Verificar sincronização NTP a cada 1h
}

// =============================================================================
// MÁQUINA DE ESTADOS
// =============================================================================
typedef enum : uint8_t {
    STATE_IDLE = 0,        // Aguardando login do operador
    STATE_LOGGED_IN,       // Operador logado, aguardando referência
    STATE_PRODUCING,       // Produzindo (com referência)
    STATE_PAUSED           // Parada ativa
} SystemState;

const char* STATE_NAMES[] = {
    "IDLE", "LOGGED_IN", "PRODUCING", "PAUSED"
};

// =============================================================================
// TIPOS DE PARADA
// =============================================================================
typedef enum : uint8_t {
    PARADA_NONE = 0,
    PARADA_BANHEIRO = 1,
    PARADA_MANUTENCAO = 2,
    PARADA_FALTA_MATERIAL = 3,
    PARADA_QUEBRA_AGULHA = 4,
    PARADA_TROCA_PECA = 5,
    PARADA_COUNT = 6
} ParadaTipo;

typedef struct {
    const char* json_name;
    const char* display_name;
} ParadaInfo;

const ParadaInfo PARADAS[PARADA_COUNT] = {
    {"none",          ""},
    {"Banheiro",      "Banheiro"},
    {"Manutencao",    "Manutencao"},
    {"FaltaMaterial", "Falt. Material"},
    {"QuebraAgulha",  "Quebra Agulha"},
    {"TrocaPeca",     "Troca Peca"}
};

// =============================================================================
// CONTEXTO DO SISTEMA (substitui variáveis globais dispersas)
// =============================================================================
typedef struct {
    // Estado principal
    SystemState state;
    SystemState prev_state;

    // Identificadores (8 hex chars + null)
    char operador_uid[9];
    char referencia_uid[9];

    // Parada
    ParadaTipo parada_ativa;

    // RPM - Buffer circular com índice de escrita
    volatile uint32_t pulse_count;
    uint32_t rpm_buffer[3];
    uint8_t rpm_write_index;
    float rpm_atual;

    // Timestamps (não-bloqueante)
    uint32_t last_rpm_calc;
    uint32_t last_mqtt_send;
    uint32_t last_display_update;
    uint32_t last_rfid_read;
    uint32_t last_rfid_poll;
    uint32_t last_wifi_attempt;
    uint32_t last_mqtt_attempt;
    uint32_t temp_message_start;
    uint32_t last_ntp_check;

    // Sincronização NTP
    time_t last_ntp_sync_unix;      // Timestamp Unix da última sincronização
    uint32_t next_mqtt_milestone;   // Próximo múltiplo de 3s para envio MQTT
    bool ntp_synced;                // Flag de sincronização NTP ativa

    // Backoff exponencial
    uint32_t wifi_retry_delay;
    uint32_t mqtt_retry_delay;

    // Flags de controle
    bool display_dirty;
    bool state_changed;
    bool mqtt_send_pending;
    bool temp_message_active;
    bool modo_parada_input;

    // Buffer de entrada teclado
    char keypad_buffer[4];
    uint8_t keypad_buffer_len;

    // Métricas do sistema
    float cpu_load;
    float heap_load;

    // Mensagem temporária
    char temp_message[21];

    // Cache do display para evitar flickering
    char lcd_cache[4][21];
} SystemContext;

// Instância global do contexto
static SystemContext ctx;

// =============================================================================
// OBJETOS DE HARDWARE
// =============================================================================
LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);
MFRC522 rfid(SS_PIN, RST_PIN);
WiFiClient wifiClient;
PubSubClient mqtt(wifiClient);

// Configuração do teclado
const byte KEYPAD_ROWS = 4;
const byte KEYPAD_COLS = 3;
char keypad_keys[KEYPAD_ROWS][KEYPAD_COLS] = {
    {'1', '2', '3'},
    {'4', '5', '6'},
    {'7', '8', '9'},
    {'*', '0', '#'}
};
byte keypad_row_pins[KEYPAD_ROWS] = {12, 33, 16, 27};
byte keypad_col_pins[KEYPAD_COLS] = {14, 13, 17};
Keypad keypad = Keypad(makeKeymap(keypad_keys), keypad_row_pins, keypad_col_pins, KEYPAD_ROWS, KEYPAD_COLS);

// =============================================================================
// ISR - CONTAGEM DE PULSOS (Otimizada)
// =============================================================================
void IRAM_ATTR onEncoderPulse() {
    // ISR configurada para FALLING edge - pino já está LOW
    // digitalRead() é desnecessário e custoso (~3µs)
    ctx.pulse_count++;
}

// =============================================================================
// INICIALIZAÇÃO DO CONTEXTO
// =============================================================================
void initContext() {
    memset(&ctx, 0, sizeof(SystemContext));
    ctx.state = STATE_IDLE;
    ctx.prev_state = STATE_IDLE;
    ctx.parada_ativa = PARADA_NONE;
    ctx.display_dirty = true;
    ctx.wifi_retry_delay = Timing::WIFI_RETRY_BASE;
    ctx.mqtt_retry_delay = Timing::MQTT_RETRY_BASE;
    ctx.ntp_synced = false;
}

// =============================================================================
// SINCRONIZAÇÃO NTP
// =============================================================================
void syncNTP() {
    DEBUG_PRINTLN("[NTP] Iniciando sincronização...");

    // Configurar SNTP
    configTime(Config::GMT_OFFSET, Config::DST_OFFSET,
               Config::NTP_SERVER1, Config::NTP_SERVER2);

    // Aguardar sincronização (timeout de 10s, não-bloqueante em produção)
    time_t now = 0;
    struct tm timeinfo;
    int retry = 0;
    const int MAX_RETRIES = 50;  // 50 × 200ms = 10s

    while (retry++ < MAX_RETRIES) {
        time(&now);
        localtime_r(&now, &timeinfo);

        // Verificar se ano é válido (>= 2020)
        if (timeinfo.tm_year >= (2020 - 1900)) {
            ctx.ntp_synced = true;
            ctx.last_ntp_sync_unix = now;
            ctx.last_ntp_check = millis();

            // Calcular próximo múltiplo de 3s
            time_t current_unix = now;
            ctx.next_mqtt_milestone = ((current_unix / 3) + 1) * 3;

            DEBUG_PRINTF("[NTP] Sincronizado! Data: %02d/%02d/%04d %02d:%02d:%02d\n",
                timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900,
                timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
            DEBUG_PRINTF("[NTP] Próximo envio MQTT em: %ld (múltiplo de 3s)\n",
                ctx.next_mqtt_milestone);

            showTempMessage("NTP Sincronizado!");
            return;
        }

        vTaskDelay(pdMS_TO_TICKS(200));
    }

    // Falha na sincronização - sistema continua funcionando com millis()
    ctx.ntp_synced = false;
    DEBUG_PRINTLN("[NTP] FALHA na sincronização! Usando millis()");
    showTempMessage("NTP Falhou!");
}

// Verificar e ressincronizar NTP periodicamente
void checkNTPSync() {
    // Só verifica se WiFi está conectado
    if (WiFi.status() != WL_CONNECTED) {
        return;
    }

    uint32_t now = millis();

    // Verificar a cada hora se precisa ressincronizar
    if (now - ctx.last_ntp_check < Timing::NTP_SYNC_CHECK) {
        return;
    }

    ctx.last_ntp_check = now;

    // Verificar se hora ainda é válida
    time_t current_unix;
    time(&current_unix);
    struct tm timeinfo;
    localtime_r(&current_unix, &timeinfo);

    if (timeinfo.tm_year < (2020 - 1900)) {
        // Perdeu sincronização - tentar novamente
        DEBUG_PRINTLN("[NTP] Sincronização perdida! Ressincronizando...");
        ctx.ntp_synced = false;
        syncNTP();
    } else {
        DEBUG_PRINTF("[NTP] Ainda sincronizado. Data: %02d/%02d/%04d %02d:%02d:%02d\n",
            timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900,
            timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
    }
}

// =============================================================================
// TRANSIÇÃO DE ESTADOS (com validação)
// =============================================================================
bool transitionTo(SystemState new_state) {
    // Validar transições permitidas
    bool valid = false;

    switch (ctx.state) {
        case STATE_IDLE:
            valid = (new_state == STATE_LOGGED_IN);
            break;
        case STATE_LOGGED_IN:
            valid = (new_state == STATE_IDLE || new_state == STATE_PRODUCING);
            break;
        case STATE_PRODUCING:
            valid = (new_state == STATE_LOGGED_IN || new_state == STATE_PAUSED || new_state == STATE_IDLE);
            break;
        case STATE_PAUSED:
            valid = (new_state == STATE_PRODUCING || new_state == STATE_LOGGED_IN || new_state == STATE_IDLE);
            break;
    }

    if (!valid) {
        DEBUG_PRINTF("[FSM] Transicao invalida: %s -> %s\n",
            STATE_NAMES[ctx.state], STATE_NAMES[new_state]);
        return false;
    }

    DEBUG_PRINTF("[FSM] %s -> %s\n", STATE_NAMES[ctx.state], STATE_NAMES[new_state]);
    ctx.prev_state = ctx.state;
    ctx.state = new_state;
    ctx.state_changed = true;
    ctx.display_dirty = true;
    ctx.mqtt_send_pending = true;

    return true;
}

// =============================================================================
// DISPLAY - Mensagem Temporária (não bloqueante)
// =============================================================================
void showTempMessage(const char* msg) {
    strncpy(ctx.temp_message, msg, 20);
    ctx.temp_message[20] = '\0';
    ctx.temp_message_active = true;
    ctx.temp_message_start = millis();
    ctx.display_dirty = true;
}

// =============================================================================
// DISPLAY - Atualização Principal
// =============================================================================
void updateDisplay() {
    uint32_t now = millis();

    // Verificar se mensagem temporária expirou
    if (ctx.temp_message_active &&
        (now - ctx.temp_message_start >= Timing::LCD_MESSAGE_DURATION)) {
        ctx.temp_message_active = false;
        ctx.display_dirty = true;
    }

    // Só processa se dirty OU intervalo de refresh
    if (!ctx.display_dirty &&
        (now - ctx.last_display_update < Timing::DISPLAY_REFRESH)) {
        return;
    }

    ctx.last_display_update = now;
    ctx.display_dirty = false;

    // Usar buffer estático para evitar alocação de stack a cada 250ms
    static char lines[4][21];

    // Linha 0: Status do operador
    if (ctx.operador_uid[0] == '\0') {
        snprintf(lines[0], 21, "Sistema Iniciado    ");
    } else {
        snprintf(lines[0], 21, "Login: %-12s", ctx.operador_uid);
    }

    // Linha 1: Referência ou instrução
    if (ctx.temp_message_active) {
        snprintf(lines[1], 21, "%-20s", ctx.temp_message);
    } else if (ctx.operador_uid[0] == '\0') {
        snprintf(lines[1], 21, "Efetue o Login!     ");
    } else if (ctx.referencia_uid[0] == '\0') {
        snprintf(lines[1], 21, "Insira Referencia...");
    } else {
        snprintf(lines[1], 21, "REF: %-14s", ctx.referencia_uid);
    }

    // Linha 2: Parada ou input mode
    if (ctx.modo_parada_input) {
        snprintf(lines[2], 21, "Parada: %-12s", ctx.keypad_buffer);
    } else if (ctx.parada_ativa != PARADA_NONE) {
        snprintf(lines[2], 21, "Parada: %-12s", PARADAS[ctx.parada_ativa].display_name);
    } else {
        snprintf(lines[2], 21, "                    ");
    }

    // Linha 3: RPM
    // Nota: (int) cast é importante porque %f pode causar issues
    snprintf(lines[3], 21, "RPM: %-15d", (int)ctx.rpm_atual);

    // Atualizar apenas o que mudou (Anti-Flicker)
    for (int i = 0; i < 4; i++) {
        // Garante terminação nula
        lines[i][20] = '\0';
        
        if (strcmp(lines[i], ctx.lcd_cache[i]) != 0) {
            lcd.setCursor(0, i);
            lcd.print(lines[i]);
            // Atualiza cache
            strcpy(ctx.lcd_cache[i], lines[i]);
        }
    }
}

// =============================================================================
// RFID - Leitura e Processamento
// =============================================================================
bool readRfidUid(char* uid_out) {
    if (!rfid.PICC_IsNewCardPresent() || !rfid.PICC_ReadCardSerial()) {
        return false;
    }

    // Converter para hex string
    for (byte i = 0; i < rfid.uid.size && i < 4; i++) {
        sprintf(&uid_out[i * 2], "%02X", rfid.uid.uidByte[i]);
    }
    uid_out[8] = '\0';

    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();

    return true;
}

void processRfid() {
    uint32_t now = millis();

    // Debounce não-bloqueante (após leitura com sucesso)
    if (now - ctx.last_rfid_read < Timing::RFID_DEBOUNCE) {
        return;
    }

    // Limitar taxa de polling (reduz uso de CPU)
    if (now - ctx.last_rfid_poll < Timing::RFID_POLL_INTERVAL) {
        return;
    }

    char uid[9];
    if (!readRfidUid(uid)) {
        // Atualiza timestamp mesmo sem leitura (para controlar polling)
        ctx.last_rfid_poll = now;
        return;
    }

    // Sucesso na leitura - atualiza ambos os timestamps
    ctx.last_rfid_poll = now;
    ctx.last_rfid_read = now;
    DEBUG_PRINTF("[RFID] UID lido: %s\n", uid);

    switch (ctx.state) {
        case STATE_IDLE:
            // Login do operador
            strncpy(ctx.operador_uid, uid, 9);
            transitionTo(STATE_LOGGED_IN);
            DEBUG_PRINTF("[RFID] Operador logado: %s\n", ctx.operador_uid);
            break;

        case STATE_LOGGED_IN:
            if (strcmp(uid, ctx.operador_uid) == 0) {
                // Logout do operador
                ctx.operador_uid[0] = '\0';
                transitionTo(STATE_IDLE);
                DEBUG_PRINTLN("[RFID] Logout do operador");
            } else {
                // Definir referência
                strncpy(ctx.referencia_uid, uid, 9);
                transitionTo(STATE_PRODUCING);
                DEBUG_PRINTF("[RFID] Referencia definida: %s\n", ctx.referencia_uid);
            }
            break;

        case STATE_PRODUCING:
        case STATE_PAUSED:
            if (strcmp(uid, ctx.operador_uid) == 0) {
                // Logout completo
                ctx.operador_uid[0] = '\0';
                ctx.referencia_uid[0] = '\0';
                ctx.parada_ativa = PARADA_NONE;
                ctx.modo_parada_input = false;
                transitionTo(STATE_IDLE);
                DEBUG_PRINTLN("[RFID] Logout completo");
            } else if (strcmp(uid, ctx.referencia_uid) == 0) {
                // Finalizar referência
                ctx.referencia_uid[0] = '\0';
                ctx.parada_ativa = PARADA_NONE;
                transitionTo(STATE_LOGGED_IN);
                showTempMessage("REF finalizada");
                DEBUG_PRINTLN("[RFID] Referencia finalizada");
            } else {
                // Outro cartão - não permitido
                showTempMessage("REF ja ativa!");
                DEBUG_PRINTLN("[RFID] Tentativa rejeitada");
            }
            break;
    }
}

// =============================================================================
// TECLADO - Processamento
// =============================================================================
void processKeypad() {
    // Só processa se logado
    if (ctx.state == STATE_IDLE) {
        return;
    }

    char key = keypad.getKey();
    if (key == 0) {
        return;
    }

    DEBUG_PRINTF("[KEY] Tecla: %c\n", key);

    switch (key) {
        case '*':
            if (ctx.modo_parada_input) {
                // Cancelar entrada
                ctx.modo_parada_input = false;
                ctx.keypad_buffer_len = 0;
                ctx.keypad_buffer[0] = '\0';
                ctx.display_dirty = true;
            } else if (ctx.parada_ativa != PARADA_NONE) {
                // Desativar parada atual
                ctx.parada_ativa = PARADA_NONE;
                if (ctx.state == STATE_PAUSED) {
                    transitionTo(STATE_PRODUCING);
                }
                DEBUG_PRINTLN("[KEY] Parada desativada");
            } else if (ctx.state == STATE_PRODUCING) {
                // Entrar modo parada
                ctx.modo_parada_input = true;
                ctx.keypad_buffer_len = 0;
                ctx.keypad_buffer[0] = '\0';
                ctx.display_dirty = true;
                DEBUG_PRINTLN("[KEY] Modo parada ativado");
            }
            break;

        case '#':
            if (ctx.modo_parada_input && ctx.keypad_buffer_len > 0) {
                // Confirmar parada
                int codigo = atoi(ctx.keypad_buffer);
                if (codigo >= 1 && codigo < PARADA_COUNT) {
                    ctx.parada_ativa = (ParadaTipo)codigo;
                    transitionTo(STATE_PAUSED);
                    DEBUG_PRINTF("[KEY] Parada ativada: %s\n",
                        PARADAS[ctx.parada_ativa].display_name);
                } else {
                    showTempMessage("Codigo invalido!");
                }
                ctx.modo_parada_input = false;
                ctx.keypad_buffer_len = 0;
                ctx.keypad_buffer[0] = '\0';
            }
            break;

        default:
            if (ctx.modo_parada_input && key >= '0' && key <= '9') {
                if (ctx.keypad_buffer_len < 2) {  // Máximo 2 dígitos
                    ctx.keypad_buffer[ctx.keypad_buffer_len++] = key;
                    ctx.keypad_buffer[ctx.keypad_buffer_len] = '\0';
                    ctx.display_dirty = true;
                }
            }
            break;
    }
}

// =============================================================================
// RPM - Cálculo
// =============================================================================
void calculateRpm() {
    uint32_t now = millis();

    if (now - ctx.last_rpm_calc < Timing::RPM_CALC_INTERVAL) {
        return;
    }

    // Ler e resetar contador atomicamente
    portDISABLE_INTERRUPTS();
    uint32_t pulses = ctx.pulse_count;
    ctx.pulse_count = 0;
    portENABLE_INTERRUPTS();

    // Calcular RPM (pulsos por minuto)
    ctx.rpm_atual = pulses * 60.0f;

    // Armazenar no buffer circular
    ctx.rpm_buffer[ctx.rpm_write_index] = (uint32_t)ctx.rpm_atual;
    ctx.rpm_write_index = (ctx.rpm_write_index + 1) % 3;

    ctx.last_rpm_calc = now;
    ctx.display_dirty = true;
}

// =============================================================================
// MÉTRICAS DO SISTEMA
// =============================================================================
void updateMetrics(uint32_t active_time_us) {
    static uint32_t work_accumulator = 0;
    static uint32_t last_calc = 0;

    work_accumulator += active_time_us;

    // Calcular CPU load a cada 1000ms (janela de medição)
    if (millis() - last_calc >= 1000) {
        // CPU load = (tempo_trabalhando / tempo_total) * 100
        // Janela de 1s = 1,000,000us
        
        ctx.cpu_load = (work_accumulator / 1000000.0f) * 100.0f;
        if (ctx.cpu_load > 100.0f) ctx.cpu_load = 100.0f;

        work_accumulator = 0;
        last_calc = millis();
    }

    // Heap usage
    size_t total_heap = heap_caps_get_total_size(MALLOC_CAP_DEFAULT);
    size_t free_heap = esp_get_free_heap_size();
    ctx.heap_load = (total_heap > 0) ?
        ((total_heap - free_heap) * 100.0f / total_heap) : 0.0f;
}

// =============================================================================
// MQTT - Envio de JSON (SINCRONIZADO COM NTP)
// =============================================================================
void sendMqttPayload() {
    if (!mqtt.connected()) {
        return;
    }

    bool should_send = false;

    // Modo SINCRONIZADO (com NTP) - Envia exatamente em múltiplos de 3s
    if (ctx.ntp_synced) {
        time_t current_unix;
        time(&current_unix);

        // Verificar se atingiu o próximo múltiplo de 3s
        if (current_unix >= ctx.next_mqtt_milestone || ctx.mqtt_send_pending) {
            should_send = true;

            // Calcular próximo múltiplo de 3s
            ctx.next_mqtt_milestone = ((current_unix / 3) + 1) * 3;

            DEBUG_PRINTF("[MQTT] Envio sincronizado em %ld (próximo: %ld)\n",
                current_unix, ctx.next_mqtt_milestone);
        }
    }
    // Modo FALLBACK (sem NTP) - Usa millis() tradicional
    else {
        uint32_t now = millis();
        should_send = (now - ctx.last_mqtt_send >= Timing::MQTT_SEND_INTERVAL) ||
                      ctx.mqtt_send_pending;

        if (should_send) {
            ctx.last_mqtt_send = now;
            DEBUG_PRINTLN("[MQTT] Envio fallback (sem NTP)");
        }
    }

    if (!should_send) {
        return;
    }

    ctx.mqtt_send_pending = false;

    // Construir JSON (formato otimizado - state como single source of truth)
    StaticJsonDocument<256> doc;

    doc["maquina_id"] = Config::MACHINE_ID;

    // Timestamp sincronizado (Unix epoch em segundos)
    if (ctx.ntp_synced) {
        time_t current_unix;
        time(&current_unix);
        doc["timestamp"] = current_unix;
    } else {
        doc["timestamp"] = 0;  // 0 indica que não está sincronizado
    }

    doc["operador"] = ctx.operador_uid;
    doc["ref_op"] = ctx.referencia_uid;
    doc["state"] = STATE_NAMES[ctx.state];
    doc["parada"] = PARADAS[ctx.parada_ativa].json_name;

    // RPM em ordem cronológica (mais antigo primeiro)
    JsonArray rpm_array = doc.createNestedArray("rpm");
    for (int i = 0; i < 3; i++) {
        uint8_t idx = (ctx.rpm_write_index + i) % 3;
        rpm_array.add(ctx.rpm_buffer[idx]);
    }

    doc["cpuLoad"] = roundf(ctx.cpu_load * 100) / 100.0f;
    doc["heapLoad"] = roundf(ctx.heap_load * 100) / 100.0f;

    // Serializar e enviar (buffer estático para reduzir stack)
    static char buffer[256];
    size_t len = serializeJson(doc, buffer);

    if (mqtt.publish(Config::MQTT_TOPIC, buffer, len)) {
        DEBUG_PRINTF("[MQTT] Enviado (%d bytes)\n", len);
    } else {
        DEBUG_PRINTLN("[MQTT] Erro ao enviar");
    }
}

// =============================================================================
// WIFI - Conexão com backoff exponencial (NÃO-BLOQUEANTE)
// =============================================================================
void handleWifiConnection() {
    static bool connecting = false;
    static uint32_t connect_start = 0;
    static const uint32_t WIFI_TIMEOUT = 10000;  // 10s timeout

    wl_status_t status = WiFi.status();

    if (status == WL_CONNECTED) {
        if (connecting) {
            DEBUG_PRINTF("[WIFI] Conectado! IP: %s\n", WiFi.localIP().toString().c_str());
            showTempMessage("WiFi Conectado!");
            ctx.display_dirty = true;
            connecting = false;
        }
        ctx.wifi_retry_delay = Timing::WIFI_RETRY_BASE;
        return;
    }

    uint32_t now = millis();

    // Se está tentando conectar, verificar timeout
    if (connecting) {
        if (now - connect_start > WIFI_TIMEOUT) {
            DEBUG_PRINTLN("[WIFI] Timeout");
            WiFi.disconnect();
            connecting = false;
            ctx.wifi_retry_delay = min(ctx.wifi_retry_delay * 2, Timing::WIFI_RETRY_MAX);
        }
        return;  // Aguardar conexão assíncrona
    }

    // Verificar se é hora de tentar reconectar
    if (now - ctx.last_wifi_attempt < ctx.wifi_retry_delay) {
        return;
    }

    // Iniciar nova tentativa de conexão
    ctx.last_wifi_attempt = now;
    connect_start = now;
    connecting = true;

    DEBUG_PRINTF("[WIFI] Conectando... (retry em %lums)\n", ctx.wifi_retry_delay);
    lcd.setCursor(0, 1);
    lcd.print("Conectando WiFi...  ");

    WiFi.disconnect();
    WiFi.begin(Config::WIFI_SSID, Config::WIFI_PASS);
    // WiFi.begin() retorna imediatamente - conexão acontece em background
}

// =============================================================================
// MQTT - Conexão com backoff exponencial
// =============================================================================
void handleMqttConnection() {
    if (mqtt.connected()) {
        ctx.mqtt_retry_delay = Timing::MQTT_RETRY_BASE;
        return;
    }

    if (WiFi.status() != WL_CONNECTED) {
        return;
    }

    uint32_t now = millis();
    if (now - ctx.last_mqtt_attempt < ctx.mqtt_retry_delay) {
        return;
    }

    ctx.last_mqtt_attempt = now;
    DEBUG_PRINTF("[MQTT] Conectando... (retry em %lums)\n", ctx.mqtt_retry_delay);

    if (mqtt.connect(Config::MACHINE_ID)) {
        DEBUG_PRINTLN("[MQTT] Conectado!");
        ctx.mqtt_retry_delay = Timing::MQTT_RETRY_BASE;
        ctx.mqtt_send_pending = true;  // Enviar estado atual imediatamente
    } else {
        ctx.mqtt_retry_delay = min(ctx.mqtt_retry_delay * 2, Timing::MQTT_RETRY_MAX);
        DEBUG_PRINTF("[MQTT] Falha (rc=%d). Proximo retry em %lums\n",
            mqtt.state(), ctx.mqtt_retry_delay);
    }
}

// =============================================================================
// SETUP
// =============================================================================
void setup() {
#ifdef DEBUG_SERIAL
    Serial.begin(115200);
    DEBUG_PRINTLN("\n[BOOT] Sistema de Monitoramento v2.0");
#endif

    // Inicializar contexto
    initContext();

    // Configurar pino do encoder
    pinMode(ENCODER_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(ENCODER_PIN), onEncoderPulse, FALLING);

    // Inicializar I2C e LCD
    Wire.begin(I2C_SDA, I2C_SCL);
    lcd.init();
    lcd.backlight();
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Iniciando...");

    // Inicializar SPI e RFID
    SPI.begin();
    rfid.PCD_Init();
    delay(100);

    if (rfid.PCD_PerformSelfTest()) {
        DEBUG_PRINTLN("[RFID] Self-test OK");
    } else {
        DEBUG_PRINTLN("[RFID] Self-test FALHOU");
    }
    rfid.PCD_Init();  // Re-init após self-test

    // Configurar MQTT
    mqtt.setServer(Config::MQTT_SERVER, Config::MQTT_PORT);
    mqtt.setBufferSize(512);

    // Conexão inicial
    handleWifiConnection();

    // Aguardar WiFi conectar antes de sincronizar NTP (timeout 10s)
    int wifi_retry = 0;
    while (WiFi.status() != WL_CONNECTED && wifi_retry++ < 50) {
        delay(200);
    }

    // Sincronizar NTP se WiFi conectou
    if (WiFi.status() == WL_CONNECTED) {
        syncNTP();
    } else {
        DEBUG_PRINTLN("[NTP] Pulando - WiFi não conectado");
    }

    handleMqttConnection();

    ctx.display_dirty = true;
    DEBUG_PRINTLN("[BOOT] Setup completo");
}

// =============================================================================
// LOOP PRINCIPAL (Zero blocking delays)
// =============================================================================
void loop() {
    uint32_t start_work = micros();

    // Gerenciar conexões
    handleWifiConnection();
    handleMqttConnection();
    mqtt.loop();

    // Verificar sincronização NTP periodicamente
    checkNTPSync();

    // Processar entradas
    processRfid();
    processKeypad();

    // Calcular métricas
    calculateRpm();
    // updateMetrics movido para o final para contabilizar tempo total

    // Atualizar saídas
    updateDisplay();
    sendMqttPayload();

    // Reset flag de mudança de estado
    ctx.state_changed = false;

    // Calcular tempo ativo antes de dormir
    uint32_t active_time = micros() - start_work;
    updateMetrics(active_time);

    // Yield para outras tasks do FreeRTOS
    vTaskDelay(pdMS_TO_TICKS(10));
}