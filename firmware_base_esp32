#include <WiFi.h>
// #include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <SPI.h>
#include <MFRC522.h>
#include "esp_heap_caps.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define RST_PIN 4
#define SS_PIN 5
#define ENCODER_PIN 34
#define PULSES_PER_REV 20

LiquidCrystal_I2C lcd(0x27, 20, 4);

const byte ROWS = 4;
const byte COLS = 3;
char keys[ROWS][COLS] = {
  {'1','2','3'},
  {'4','5','6'},
  {'7','8','9'},
  {'*','0','#'}
};
byte rowPins[ROWS] = {12, 33, 25, 27};
byte colPins[COLS] = {14, 13, 26};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

const char* ssid = "CLAYRAFA";
const char* password = "kadu1973";
const char* mqtt_server = "192.168.100.24";
const int mqtt_port = 1883;
const char* mqtt_topic = "esp32";
// const char* mqtt_user = "esp32";
// const char* mqtt_password = "Projetoesp32";

// WiFiClientSecure secureClient;
// PubSubClient client(secureClient);
WiFiClient espClient;
PubSubClient client(espClient);
MFRC522 rfid(SS_PIN, RST_PIN);

String operador_id = "";
String referencia = "";
bool tempoMaquina = false, tempoProducao = false;
bool tempoBanheiro = false, tempoManutencao = false, tempoFaltaMaterial = false, tempoQuebraAgulha = false, tempoTrocaPeca = false;

volatile unsigned long pulseCount = 0;
unsigned long lastRPMCheck = 0;
float rpm = 0;
float cpuLoad = 0.0f;

void IRAM_ATTR countPulse() {
  pulseCount++;
}

void resetarParadas() {
  tempoBanheiro = tempoManutencao = tempoFaltaMaterial = tempoQuebraAgulha = tempoTrocaPeca = false;
}

void verificarRFID() {
  if (!rfid.PICC_IsNewCardPresent() || !rfid.PICC_ReadCardSerial()) return;
  String uid = "";
  for (byte i = 0; i < rfid.uid.size; i++) uid += String(rfid.uid.uidByte[i], HEX);
  uid.toUpperCase();

  if (operador_id == "") {
    operador_id = uid;
    tempoMaquina = true;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Login: " + operador_id);
    lcd.setCursor(0, 1);
    lcd.print("Sete Referencia...");
  } else {
    operador_id = "";
    tempoMaquina = tempoProducao = false;
    referencia = "";
    resetarParadas();
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Logout Realizado");
  }
  delay(1000);
}

void verificarTeclado() {
  static String buffer = "";
  char key = keypad.getKey();
  if (key) {
    if (key == '#') {
      int valor = buffer.toInt();
      if (valor >= 15) {
        referencia = "REF_" + buffer;
        tempoProducao = true;
        lcd.setCursor(0, 1);
        lcd.print("Referencia: " + referencia);
      } else {
        bool* paradaAtual = nullptr;
        if (valor == 1) paradaAtual = &tempoBanheiro;
        else if (valor == 3) paradaAtual = &tempoManutencao;
        else if (valor == 4) paradaAtual = &tempoFaltaMaterial;
        else if (valor == 5) paradaAtual = &tempoQuebraAgulha;
        else if (valor == 6) paradaAtual = &tempoTrocaPeca;

        if (paradaAtual) {
          if (!(tempoBanheiro || tempoManutencao || tempoFaltaMaterial || tempoQuebraAgulha || tempoTrocaPeca)) *paradaAtual = true;
          else if (*paradaAtual) *paradaAtual = false;
        }
      }
      buffer = "";
    } else {
      buffer += key;
    }
  }
}

float getCPULoad() {
  static unsigned long lastIdle = 0, lastTotal = 0;
  unsigned long idle = ulTaskGetIdleRunTimeCounter();
  unsigned long total = portGET_RUN_TIME_COUNTER_VALUE();
  unsigned long idleDelta = idle - lastIdle;
  unsigned long totalDelta = total - lastTotal;
  lastIdle = idle;
  lastTotal = total;
  if (totalDelta == 0) return 0.0;
  return (1.0 - ((float)idleDelta / totalDelta)) * 100.0;
}

void enviarJSON() {
  String json = "{";
  json += "\"operador\":\"" + operador_id + "\",";
  json += "\"referencia\":\"" + referencia + "\",";
  json += "\"tempoMaquina\":" + String(tempoMaquina ? "true" : "false") + ",";
  json += "\"tempoProducao\":" + String(tempoProducao ? "true" : "false") + ",";
  json += "\"tempoBanheiro\":" + String(tempoBanheiro ? "true" : "false") + ",";
  json += "\"tempoManutencao\":" + String(tempoManutencao ? "true" : "false") + ",";
  json += "\"tempoFaltaMaterial\":" + String(tempoFaltaMaterial ? "true" : "false") + ",";
  json += "\"tempoQuebraAgulha\":" + String(tempoQuebraAgulha ? "true" : "false") + ",";
  json += "\"tempoTrocaPeca\":" + String(tempoTrocaPeca ? "true" : "false") + ",";
  json += "\"rpm\":" + String(rpm, 2) + ",";
  json += "\"cpuLoad\":" + String(cpuLoad, 1) + ",";
  json += "\"heapLivre\":" + String(esp_get_free_heap_size()) + ",";
  json += "\"heapMin\":" + String(esp_get_minimum_free_heap_size());
  json += "}";

  Serial.println(json);
  if (client.connected()) client.publish(mqtt_topic, json.c_str());
}

void conectarWiFi() {
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi conectado! IP: ");
  Serial.println(WiFi.localIP());
}

void conectarMQTT() {
  client.setServer(mqtt_server, mqtt_port);
  while (!client.connected()) {
    Serial.print("Conectando ao MQTT...");
    if (client.connect("ESP32Client")) {
      Serial.println("Conectado ao MQTT!");
    } else {
      Serial.print("Falha, rc=");
      Serial.print(client.state());
      Serial.println(" Tentando novamente em 5s");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(ENCODER_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENCODER_PIN), countPulse, RISING);

  Wire.begin(21, 22);
  lcd.init(); lcd.backlight();
  lcd.setCursor(0, 0); lcd.print("Sistema Iniciado");

  SPI.begin(); rfid.PCD_Init();
  conectarWiFi(); conectarMQTT();
}

void loop() {
  if (!client.connected()) conectarMQTT();
  client.loop();

  verificarRFID();
  verificarTeclado();

  if (millis() - lastRPMCheck >= 1000) {
    detachInterrupt(digitalPinToInterrupt(ENCODER_PIN));
    rpm = (pulseCount * 60.0) / PULSES_PER_REV;
    pulseCount = 0;
    lastRPMCheck = millis();
    attachInterrupt(digitalPinToInterrupt(ENCODER_PIN), countPulse, RISING);
    cpuLoad = getCPULoad();
    lcd.setCursor(0, 3);
    lcd.printf("RPM: %.2f CPU: %.1f%%", rpm, cpuLoad);
  }

  static unsigned long ultimaMensagem = 0;
  if (millis() - ultimaMensagem >= 3000) {
    enviarJSON();
    ultimaMensagem = millis();
  }

  vTaskDelay(1);
}
